/*
TwelveLabs Video Understanding API

Use the TwelveLabs Video Understanding API to extract information from your videos and make it available to your applications. The API is organized around REST and returns responses in the JSON format. It is compatible with most programming languages, and you can also use Postman or other REST clients to send requests and view responses. 

API version: 1.3.0
Contact: support@twelvelabs.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package twelvelabs

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// CreateTextImageAndAudioEmbeddingsAPIService CreateTextImageAndAudioEmbeddingsAPI service
type CreateTextImageAndAudioEmbeddingsAPIService service

type ApiCreateTextImageAudioEmbeddingRequest struct {
	ctx context.Context
	ApiService *CreateTextImageAndAudioEmbeddingsAPIService
	xApiKey *string
	contentType *string
	modelName *string
	text *string
	textTruncate *string
	imageUrl *string
	imageFile *os.File
	audioUrl *string
	audioFile *os.File
	audioStartOffsetSec *float32
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiCreateTextImageAudioEmbeddingRequest) XApiKey(xApiKey string) ApiCreateTextImageAudioEmbeddingRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;multipart/form-data&#x60;.
func (r ApiCreateTextImageAudioEmbeddingRequest) ContentType(contentType string) ApiCreateTextImageAudioEmbeddingRequest {
	r.contentType = &contentType
	return r
}

// The name of the model you want to use. The following models are available:   - &#x60;Marengo-retrieval-2.7&#x60; 
func (r ApiCreateTextImageAudioEmbeddingRequest) ModelName(modelName string) ApiCreateTextImageAudioEmbeddingRequest {
	r.modelName = &modelName
	return r
}

// The text for which you wish to create an embedding.  &lt;Note title&#x3D;\\\&quot;Note\\\&quot;&gt; Text embeddings are limited to 77 tokens. If the text exceeds this limit, the platform truncates it according to the value of the &#x60;text_truncate&#x60; parameter described below. &lt;/Note&gt;  **Example**: \\\&quot;Man with a dog crossing the street\\\&quot; 
func (r ApiCreateTextImageAudioEmbeddingRequest) Text(text string) ApiCreateTextImageAudioEmbeddingRequest {
	r.text = &text
	return r
}

// Specifies how the platform truncates text that exceeds 77 tokens to fit the maximum length allowed for an embedding. This parameter can take one of the following values: - &#x60;start&#x60;: The platform will truncate the start of the provided text. - &#x60;end&#x60;: The platform will truncate the end of the provided text. - &#x60;none&#x60;: The platform will return an error if the text is longer than the maximum token limit.  **Default**: &#x60;end&#x60; 
func (r ApiCreateTextImageAudioEmbeddingRequest) TextTruncate(textTruncate string) ApiCreateTextImageAudioEmbeddingRequest {
	r.textTruncate = &textTruncate
	return r
}

// The publicly accessible URL of the image for which you wish to create an embedding. This parameter is required for image embeddings if &#x60;image_file&#x60; is not provided. 
func (r ApiCreateTextImageAudioEmbeddingRequest) ImageUrl(imageUrl string) ApiCreateTextImageAudioEmbeddingRequest {
	r.imageUrl = &imageUrl
	return r
}

// The image file for which you wish to create an embedding as a local file. This parameter is required for image embeddings if &#x60;image_url&#x60; is not provided. 
func (r ApiCreateTextImageAudioEmbeddingRequest) ImageFile(imageFile *os.File) ApiCreateTextImageAudioEmbeddingRequest {
	r.imageFile = imageFile
	return r
}

// The publicly accessible URL of the audio file for which you wish to creae an emebdding. This parameter is required for audio embeddings if &#x60;audio_file&#x60; is not provided. 
func (r ApiCreateTextImageAudioEmbeddingRequest) AudioUrl(audioUrl string) ApiCreateTextImageAudioEmbeddingRequest {
	r.audioUrl = &audioUrl
	return r
}

// The audio file for which you wish to create an embedding as a local file. This parameter is required for audio embeddings if &#x60;audio_url&#x60; is not provided. 
func (r ApiCreateTextImageAudioEmbeddingRequest) AudioFile(audioFile *os.File) ApiCreateTextImageAudioEmbeddingRequest {
	r.audioFile = audioFile
	return r
}

// Specifies the start time, in seconds, from which the platform generates the audio embeddings. This parameter allows you to skip the initial portion of the audio during processing. **Default**: &#x60;0&#x60;. 
func (r ApiCreateTextImageAudioEmbeddingRequest) AudioStartOffsetSec(audioStartOffsetSec float32) ApiCreateTextImageAudioEmbeddingRequest {
	r.audioStartOffsetSec = &audioStartOffsetSec
	return r
}

func (r ApiCreateTextImageAudioEmbeddingRequest) Execute() (*EmbeddingResponse, *http.Response, error) {
	return r.ApiService.CreateTextImageAudioEmbeddingExecute(r)
}

/*
CreateTextImageAudioEmbedding Create embeddings for text, image, and audio

This method creates embeddings for text, image, and audio content.

Before you create an embedding, ensure that your image or audio files meet the following prerequisites:
- [Image embeddings](/v1.3/docs/guides/create-embeddings/image#prerequisites)
- [Audio embeddings](/v1.3/docs/guides/create-embeddings/audio#prerequisites)

Parameters for embeddings:
- **Common parameters**:
  - `model_name`: The video understanding model you want to use. Example: "Marengo-retrieval-2.7".
- **Text embeddings**:
  - `text`: Text for which to create an embedding.
- **Image embeddings**:
  Provide one of the following:
  - `image_url`: Publicly accessible URL of your image file.
  - `image_file`:  Local image file.
- **Audio embeddings**:
  Provide one of the following:
  - `audio_url`: Publicly accessible URL of your audio file.
  - `audio_file`: Local audio file.

<Note title="Notes">
- The "Marengo-retrieval-2.7" video understanding model generates embeddings for all modalities in the same latent space. This shared space enables any-to-any searches across different types of content.
- You can create multiple types of embeddings in a single API call.
- Audio embeddings combine generic sound and human speech in a single embedding. For videos with transcriptions, you can retrieve transcriptions and then [create text embeddings](/v1.3/api-reference/text-image-audio-embeddings/create-text-image-audio-embeddings) from these transcriptions.
</Note>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTextImageAudioEmbeddingRequest
*/
func (a *CreateTextImageAndAudioEmbeddingsAPIService) CreateTextImageAudioEmbedding(ctx context.Context) ApiCreateTextImageAudioEmbeddingRequest {
	return ApiCreateTextImageAudioEmbeddingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmbeddingResponse
func (a *CreateTextImageAndAudioEmbeddingsAPIService) CreateTextImageAudioEmbeddingExecute(r ApiCreateTextImageAudioEmbeddingRequest) (*EmbeddingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmbeddingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreateTextImageAndAudioEmbeddingsAPIService.CreateTextImageAudioEmbedding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}
	if r.modelName == nil {
		return localVarReturnValue, nil, reportError("modelName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "model_name", r.modelName, "", "")
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text", r.text, "", "")
	}
	if r.textTruncate != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "text_truncate", r.textTruncate, "", "")
	}
	if r.imageUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "image_url", r.imageUrl, "", "")
	}
	var imageFileLocalVarFormFileName string
	var imageFileLocalVarFileName     string
	var imageFileLocalVarFileBytes    []byte

	imageFileLocalVarFormFileName = "image_file"
	imageFileLocalVarFile := r.imageFile

	if imageFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(imageFileLocalVarFile)

		imageFileLocalVarFileBytes = fbs
		imageFileLocalVarFileName = imageFileLocalVarFile.Name()
		imageFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: imageFileLocalVarFileBytes, fileName: imageFileLocalVarFileName, formFileName: imageFileLocalVarFormFileName})
	}
	if r.audioUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "audio_url", r.audioUrl, "", "")
	}
	var audioFileLocalVarFormFileName string
	var audioFileLocalVarFileName     string
	var audioFileLocalVarFileBytes    []byte

	audioFileLocalVarFormFileName = "audio_file"
	audioFileLocalVarFile := r.audioFile

	if audioFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(audioFileLocalVarFile)

		audioFileLocalVarFileBytes = fbs
		audioFileLocalVarFileName = audioFileLocalVarFile.Name()
		audioFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: audioFileLocalVarFileBytes, fileName: audioFileLocalVarFileName, formFileName: audioFileLocalVarFormFileName})
	}
	if r.audioStartOffsetSec != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "audio_start_offset_sec", r.audioStartOffsetSec, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
