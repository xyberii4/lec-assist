/*
TwelveLabs Video Understanding API

Use the TwelveLabs Video Understanding API to extract information from your videos and make it available to your applications. The API is organized around REST and returns responses in the JSON format. It is compatible with most programming languages, and you can also use Postman or other REST clients to send requests and view responses. 

API version: 1.3.0
Contact: support@twelvelabs.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package twelvelabs

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ManageVideosAPIService ManageVideosAPI service
type ManageVideosAPIService service

type ApiDeleteVideoInformationRequest struct {
	ctx context.Context
	ApiService *ManageVideosAPIService
	xApiKey *string
	contentType *string
	indexId string
	videoId string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiDeleteVideoInformationRequest) XApiKey(xApiKey string) ApiDeleteVideoInformationRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiDeleteVideoInformationRequest) ContentType(contentType string) ApiDeleteVideoInformationRequest {
	r.contentType = &contentType
	return r
}

func (r ApiDeleteVideoInformationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVideoInformationExecute(r)
}

/*
DeleteVideoInformation Delete video information

This method deletes all the information about the specified video This action cannot be undone.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId The unique identifier of the index to which the video has been uploaded. 
 @param videoId The unique identifier of the video to delete. 
 @return ApiDeleteVideoInformationRequest
*/
func (a *ManageVideosAPIService) DeleteVideoInformation(ctx context.Context, indexId string, videoId string) ApiDeleteVideoInformationRequest {
	return ApiDeleteVideoInformationRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
		videoId: videoId,
	}
}

// Execute executes the request
func (a *ManageVideosAPIService) DeleteVideoInformationExecute(r ApiDeleteVideoInformationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageVideosAPIService.DeleteVideoInformation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/indexes/{index-id}/videos/{video-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index-id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"video-id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListVideosRequest struct {
	ctx context.Context
	ApiService *ManageVideosAPIService
	xApiKey *string
	contentType *string
	indexId string
	page *int32
	pageLimit *int32
	sortBy *string
	sortOption *string
	filename *string
	duration *float32
	fps *float32
	width *float32
	height *int32
	size *float32
	createdAt *string
	updatedAt *string
	userMetadata *map[string]ListVideosUserMetadataParameterValue
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiListVideosRequest) XApiKey(xApiKey string) ApiListVideosRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiListVideosRequest) ContentType(contentType string) ApiListVideosRequest {
	r.contentType = &contentType
	return r
}

// A number that identifies the page to retrieve.  **Default**: &#x60;1&#x60;. 
func (r ApiListVideosRequest) Page(page int32) ApiListVideosRequest {
	r.page = &page
	return r
}

// The number of items to return on each page.  **Default**: &#x60;10&#x60;. **Max**: &#x60;50&#x60;. 
func (r ApiListVideosRequest) PageLimit(pageLimit int32) ApiListVideosRequest {
	r.pageLimit = &pageLimit
	return r
}

// The field to sort on. The following options are available: - &#x60;updated_at&#x60;: Sorts by the time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;), when the item was updated. - &#x60;created_at&#x60;: Sorts by the time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;), when the item was created.  **Default**: &#x60;created_at&#x60;. 
func (r ApiListVideosRequest) SortBy(sortBy string) ApiListVideosRequest {
	r.sortBy = &sortBy
	return r
}

// The sorting direction. The following options are available: - &#x60;asc&#x60; - &#x60;desc&#x60;  **Default**: &#x60;desc&#x60;. 
func (r ApiListVideosRequest) SortOption(sortOption string) ApiListVideosRequest {
	r.sortOption = &sortOption
	return r
}

// Filter by filename. 
func (r ApiListVideosRequest) Filename(filename string) ApiListVideosRequest {
	r.filename = &filename
	return r
}

// Filter by duration. Expressed in seconds. 
func (r ApiListVideosRequest) Duration(duration float32) ApiListVideosRequest {
	r.duration = &duration
	return r
}

// Filter by frames per second. 
func (r ApiListVideosRequest) Fps(fps float32) ApiListVideosRequest {
	r.fps = &fps
	return r
}

// Filter by width. 
func (r ApiListVideosRequest) Width(width float32) ApiListVideosRequest {
	r.width = &width
	return r
}

// Filter by height. 
func (r ApiListVideosRequest) Height(height int32) ApiListVideosRequest {
	r.height = &height
	return r
}

// Filter by size. Expressed in bytes. 
func (r ApiListVideosRequest) Size(size float32) ApiListVideosRequest {
	r.size = &size
	return r
}

// Filter videos by the creation date and time of their associated indexing tasks, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;). The platform returns the videos whose indexing tasks were created on the specified date at or after the given time. 
func (r ApiListVideosRequest) CreatedAt(createdAt string) ApiListVideosRequest {
	r.createdAt = &createdAt
	return r
}

// This filter applies only to videos updated using the [&#x60;PUT&#x60;](/v1.3/api-reference/videos/update) method of the &#x60;/indexes/{index-id}/videos/{video-id}&#x60; endpoint. It filters videos by the last update date and time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;). The platform returns the video indexing tasks that were last updated on the specified date at or after the given time. 
func (r ApiListVideosRequest) UpdatedAt(updatedAt string) ApiListVideosRequest {
	r.updatedAt = &updatedAt
	return r
}

// To enable filtering by custom fields, you must first add user-defined metadata to your video by calling the [&#x60;PUT&#x60;](/v1.3/api-reference/videos/update) method of the &#x60;/indexes/:index-id/videos/:video-id&#x60; endpoint.  Examples: - To filter on a string: &#x60;?category&#x3D;recentlyAdded&#x60; - To filter on an integer: &#x60;?batchNumber&#x3D;5&#x60; - To filter on a float: &#x60;?rating&#x3D;9.3&#x60; - To filter on a boolean: &#x60;?needsReview&#x3D;true&#x60; 
func (r ApiListVideosRequest) UserMetadata(userMetadata map[string]ListVideosUserMetadataParameterValue) ApiListVideosRequest {
	r.userMetadata = &userMetadata
	return r
}

func (r ApiListVideosRequest) Execute() (*InlineObject3, *http.Response, error) {
	return r.ApiService.ListVideosExecute(r)
}

/*
ListVideos List videos

This method returns a list of the videos in the specified index. By default, the API returns your videos sorted by creation date, with the newest at the top of the list.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId The unique identifier of the index for which the API will retrieve the videos.
 @return ApiListVideosRequest
*/
func (a *ManageVideosAPIService) ListVideos(ctx context.Context, indexId string) ApiListVideosRequest {
	return ApiListVideosRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
	}
}

// Execute executes the request
//  @return InlineObject3
func (a *ManageVideosAPIService) ListVideosExecute(r ApiListVideosRequest) (*InlineObject3, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageVideosAPIService.ListVideos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/indexes/{index-id}/videos"
	localVarPath = strings.Replace(localVarPath, "{"+"index-id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_limit", r.pageLimit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageLimit = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortBy = &defaultValue
	}
	if r.sortOption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_option", r.sortOption, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortOption = &defaultValue
	}
	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	}
	if r.fps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fps", r.fps, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	if r.userMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_metadata", r.userMetadata, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveVideoInformationRequest struct {
	ctx context.Context
	ApiService *ManageVideosAPIService
	xApiKey *string
	contentType *string
	indexId string
	videoId string
	embeddingOption *[]string
	transcription *bool
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiRetrieveVideoInformationRequest) XApiKey(xApiKey string) ApiRetrieveVideoInformationRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiRetrieveVideoInformationRequest) ContentType(contentType string) ApiRetrieveVideoInformationRequest {
	r.contentType = &contentType
	return r
}

// Specifies which types of embeddings to retrieve. You can include one or more of the following values: - &#x60;visual-text&#x60;:  Returns visual embeddings optimized for text search. - &#x60;audio&#x60;: Returns audio embeddings. &lt;br/&gt; To retrieve embeddings for a video, it must be indexed using the Marengo video understanding model version 2.7 or later. For details on enabling this model for an index, see the [Create an index](/reference/create-index) page.  The platform does not return embeddings if you don&#39;t provide this parameter.  The values you specify in &#x60;embedding_option&#x60; must be included in the &#x60;model_options&#x60; defined when the index was created. For example, if &#x60;model_options&#x60; is set to &#x60;visual,&#x60; you cannot set &#x60;embedding_option&#x60; to &#x60;audio&#x60; or  both &#x60;visual-text&#x60; and &#x60;audio&#x60;. 
func (r ApiRetrieveVideoInformationRequest) EmbeddingOption(embeddingOption []string) ApiRetrieveVideoInformationRequest {
	r.embeddingOption = &embeddingOption
	return r
}

// The parameter indicates whether to retrieve a transcription of the spoken words for the indexed video. Note that the official SDKs will support this feature in a future release. 
func (r ApiRetrieveVideoInformationRequest) Transcription(transcription bool) ApiRetrieveVideoInformationRequest {
	r.transcription = &transcription
	return r
}

func (r ApiRetrieveVideoInformationRequest) Execute() (*InlineObject4, *http.Response, error) {
	return r.ApiService.RetrieveVideoInformationExecute(r)
}

/*
RetrieveVideoInformation Retrieve video information

This method retrieves information about the specified video.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId The unique identifier of the index to which the video has been uploaded. 
 @param videoId The unique identifier of the video to retrieve. 
 @return ApiRetrieveVideoInformationRequest
*/
func (a *ManageVideosAPIService) RetrieveVideoInformation(ctx context.Context, indexId string, videoId string) ApiRetrieveVideoInformationRequest {
	return ApiRetrieveVideoInformationRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
		videoId: videoId,
	}
}

// Execute executes the request
//  @return InlineObject4
func (a *ManageVideosAPIService) RetrieveVideoInformationExecute(r ApiRetrieveVideoInformationRequest) (*InlineObject4, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject4
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageVideosAPIService.RetrieveVideoInformation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/indexes/{index-id}/videos/{video-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index-id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"video-id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	if r.embeddingOption != nil {
		t := *r.embeddingOption
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "embedding_option", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "embedding_option", t, "form", "multi")
		}
	}
	if r.transcription != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcription", r.transcription, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v InlineObject14
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVideoInformationRequest struct {
	ctx context.Context
	ApiService *ManageVideosAPIService
	xApiKey *string
	contentType *string
	indexId string
	videoId string
	updateVideoInformationRequest *UpdateVideoInformationRequest
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiUpdateVideoInformationRequest) XApiKey(xApiKey string) ApiUpdateVideoInformationRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiUpdateVideoInformationRequest) ContentType(contentType string) ApiUpdateVideoInformationRequest {
	r.contentType = &contentType
	return r
}

// Request to update the metadata of a video. 
func (r ApiUpdateVideoInformationRequest) UpdateVideoInformationRequest(updateVideoInformationRequest UpdateVideoInformationRequest) ApiUpdateVideoInformationRequest {
	r.updateVideoInformationRequest = &updateVideoInformationRequest
	return r
}

func (r ApiUpdateVideoInformationRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVideoInformationExecute(r)
}

/*
UpdateVideoInformation Update video information

Use this method to update the metadata of a video such as file name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId The unique identifier of the index to which the video has been uploaded. 
 @param videoId The unique identifier of the video to update. 
 @return ApiUpdateVideoInformationRequest
*/
func (a *ManageVideosAPIService) UpdateVideoInformation(ctx context.Context, indexId string, videoId string) ApiUpdateVideoInformationRequest {
	return ApiUpdateVideoInformationRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
		videoId: videoId,
	}
}

// Execute executes the request
func (a *ManageVideosAPIService) UpdateVideoInformationExecute(r ApiUpdateVideoInformationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageVideosAPIService.UpdateVideoInformation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/indexes/{index-id}/videos/{video-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index-id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"video-id"+"}", url.PathEscape(parameterValueToString(r.videoId, "videoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	// body params
	localVarPostBody = r.updateVideoInformationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
