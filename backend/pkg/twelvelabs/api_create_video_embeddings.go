/*
TwelveLabs Video Understanding API

Use the TwelveLabs Video Understanding API to extract information from your videos and make it available to your applications. The API is organized around REST and returns responses in the JSON format. It is compatible with most programming languages, and you can also use Postman or other REST clients to send requests and view responses. 

API version: 1.3.0
Contact: support@twelvelabs.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package twelvelabs

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
)


// CreateVideoEmbeddingsAPIService CreateVideoEmbeddingsAPI service
type CreateVideoEmbeddingsAPIService service

type ApiCreateVideoEmbeddingTaskRequest struct {
	ctx context.Context
	ApiService *CreateVideoEmbeddingsAPIService
	xApiKey *string
	contentType *string
	modelName *string
	videoFile *os.File
	videoUrl *string
	videoStartOffsetSec *float32
	videoEndOffsetSec *float32
	videoClipLength *float32
	videoEmbeddingScope *string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiCreateVideoEmbeddingTaskRequest) XApiKey(xApiKey string) ApiCreateVideoEmbeddingTaskRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;multipart/form-data&#x60;.
func (r ApiCreateVideoEmbeddingTaskRequest) ContentType(contentType string) ApiCreateVideoEmbeddingTaskRequest {
	r.contentType = &contentType
	return r
}

// The name of the model you want to use. The following models are available:   - &#x60;Marengo-retrieval-2.7&#x60; 
func (r ApiCreateVideoEmbeddingTaskRequest) ModelName(modelName string) ApiCreateVideoEmbeddingTaskRequest {
	r.modelName = &modelName
	return r
}

// Specify this parameter to upload a video from your local file system. 
func (r ApiCreateVideoEmbeddingTaskRequest) VideoFile(videoFile *os.File) ApiCreateVideoEmbeddingTaskRequest {
	r.videoFile = videoFile
	return r
}

// Specify this parameter to upload a video from a publicly accessible URL. 
func (r ApiCreateVideoEmbeddingTaskRequest) VideoUrl(videoUrl string) ApiCreateVideoEmbeddingTaskRequest {
	r.videoUrl = &videoUrl
	return r
}

// The start offset in seconds from the beginning of the video where processing should begin. Specifying 0 means starting from the beginning of the video.  **Default**: 0 **Min**: 0 **Max**: Duration of the video minus video_clip_length 
func (r ApiCreateVideoEmbeddingTaskRequest) VideoStartOffsetSec(videoStartOffsetSec float32) ApiCreateVideoEmbeddingTaskRequest {
	r.videoStartOffsetSec = &videoStartOffsetSec
	return r
}

// The end offset in seconds from the beginning of the video where processing should stop.  Ensure the following when you specify this parameter: - The end offset does not exceed the total duration of the video file. - The end offset is greater than the start offset. - You must set both the start and end offsets. Setting only one of these offsets is not permitted, resulting in an error.  **Min**: video_start_offset + video_clip_length **Max**: Duration of the video file 
func (r ApiCreateVideoEmbeddingTaskRequest) VideoEndOffsetSec(videoEndOffsetSec float32) ApiCreateVideoEmbeddingTaskRequest {
	r.videoEndOffsetSec = &videoEndOffsetSec
	return r
}

// The desired duration in seconds for each clip for which the platform generates an embedding. Ensure that the clip length does not exceed the interval between the start and end offsets.  **Default**: 6 **Min**: 2 **Max**: 10 
func (r ApiCreateVideoEmbeddingTaskRequest) VideoClipLength(videoClipLength float32) ApiCreateVideoEmbeddingTaskRequest {
	r.videoClipLength = &videoClipLength
	return r
}

// Defines the scope of video embedding generation. Valid values are the following: - &#x60;clip&#x60;: Creates embeddings for each video segment of &#x60;video_clip_length&#x60; seconds, from &#x60;video_start_offset_sec&#x60; to &#x60;video_end_offset_sec&#x60;. - &#x60;clip&#x60; and &#x60;video&#x60;: Creates embeddings for video segments and the entire video.  To create embeddings for segments and the entire video in the same request, include this parameter twice as shown below:  &#x60;&#x60;&#x60;json --form video_embedding_scope&#x3D;clip \\\\ --form video_embedding_scope&#x3D;video &#x60;&#x60;&#x60;  **Default**: &#x60;clip&#x60; 
func (r ApiCreateVideoEmbeddingTaskRequest) VideoEmbeddingScope(videoEmbeddingScope string) ApiCreateVideoEmbeddingTaskRequest {
	r.videoEmbeddingScope = &videoEmbeddingScope
	return r
}

func (r ApiCreateVideoEmbeddingTaskRequest) Execute() (*InlineObject18, *http.Response, error) {
	return r.ApiService.CreateVideoEmbeddingTaskExecute(r)
}

/*
CreateVideoEmbeddingTask Create a video embedding task

This method creates a new video embedding task that uploads a video to the platform and creates one or multiple video embeddings.

Upload options:
- **Local file**: Use the `video_file` parameter
- **Publicly accessible URL**: Use the `video_url` parameter.

Specify at least one option. If both are provided, `video_url` takes precedence.

<Accordion title="Video requirements">
  The videos you wish to upload must meet the following requirements:
  - **Video resolution**: Must be at least 360x360 and must not exceed 3840x2160.
  - **Aspect ratio**: Must be one of 1:1, 4:3, 4:5, 5:4, 16:9, or 9:16.
  - **Video and audio formats**: Your video files must be encoded in the video and audio formats listed on the [FFmpeg Formats Documentation](https://ffmpeg.org/ffmpeg-formats.html) page. For videos in other formats, contact us at support@twelvelabs.io.
  - **Duration**: Must be between 4 seconds and 2 hours (7,200s).
  - **File size**: Must not exceed 2 GB.
    If you require different options, contact us at support@twelvelabs.io.
</Accordion>

<Note title="Notes">
- The "Marengo-retrieval-2.7" video understanding model generates embeddings for all modalities in the same latent space. This shared space enables any-to-any searches across different types of content.
- Video embeddings are stored for seven days.
- The platform supports uploading video files that can play without additional user interaction or custom video players. Ensure your URL points to the raw video file, not a web page containing the video. Links to third-party hosting sites, cloud storage services, or videos requiring extra steps to play are not supported.
</Note>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVideoEmbeddingTaskRequest
*/
func (a *CreateVideoEmbeddingsAPIService) CreateVideoEmbeddingTask(ctx context.Context) ApiCreateVideoEmbeddingTaskRequest {
	return ApiCreateVideoEmbeddingTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineObject18
func (a *CreateVideoEmbeddingsAPIService) CreateVideoEmbeddingTaskExecute(r ApiCreateVideoEmbeddingTaskRequest) (*InlineObject18, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject18
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreateVideoEmbeddingsAPIService.CreateVideoEmbeddingTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embed/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}
	if r.modelName == nil {
		return localVarReturnValue, nil, reportError("modelName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "model_name", r.modelName, "", "")
	var videoFileLocalVarFormFileName string
	var videoFileLocalVarFileName     string
	var videoFileLocalVarFileBytes    []byte

	videoFileLocalVarFormFileName = "video_file"
	videoFileLocalVarFile := r.videoFile

	if videoFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(videoFileLocalVarFile)

		videoFileLocalVarFileBytes = fbs
		videoFileLocalVarFileName = videoFileLocalVarFile.Name()
		videoFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: videoFileLocalVarFileBytes, fileName: videoFileLocalVarFileName, formFileName: videoFileLocalVarFormFileName})
	}
	if r.videoUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_url", r.videoUrl, "", "")
	}
	if r.videoStartOffsetSec != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_start_offset_sec", r.videoStartOffsetSec, "", "")
	}
	if r.videoEndOffsetSec != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_end_offset_sec", r.videoEndOffsetSec, "", "")
	}
	if r.videoClipLength != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_clip_length", r.videoClipLength, "", "")
	}
	if r.videoEmbeddingScope != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_embedding_scope", r.videoEmbeddingScope, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVideoEmbeddingTasksRequest struct {
	ctx context.Context
	ApiService *CreateVideoEmbeddingsAPIService
	xApiKey *string
	startedAt *string
	endedAt *string
	status *string
	page *int32
	pageLimit *int32
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiListVideoEmbeddingTasksRequest) XApiKey(xApiKey string) ApiListVideoEmbeddingTasksRequest {
	r.xApiKey = &xApiKey
	return r
}

// Retrieve the video embedding tasks that were created after the given date and time, expressed in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;). 
func (r ApiListVideoEmbeddingTasksRequest) StartedAt(startedAt string) ApiListVideoEmbeddingTasksRequest {
	r.startedAt = &startedAt
	return r
}

// Retrieve the video embedding tasks that were created before the given date and time, expressed in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;). 
func (r ApiListVideoEmbeddingTasksRequest) EndedAt(endedAt string) ApiListVideoEmbeddingTasksRequest {
	r.endedAt = &endedAt
	return r
}

// Filter video embedding tasks by their current status. Possible values are &#x60;processing&#x60;, &#x60;ready&#x60;, or &#x60;failed&#x60;.
func (r ApiListVideoEmbeddingTasksRequest) Status(status string) ApiListVideoEmbeddingTasksRequest {
	r.status = &status
	return r
}

// A number that identifies the page to retrieve.  **Default**: &#x60;1&#x60;. 
func (r ApiListVideoEmbeddingTasksRequest) Page(page int32) ApiListVideoEmbeddingTasksRequest {
	r.page = &page
	return r
}

// The number of items to return on each page.  **Default**: &#x60;10&#x60;. **Max**: &#x60;50&#x60;. 
func (r ApiListVideoEmbeddingTasksRequest) PageLimit(pageLimit int32) ApiListVideoEmbeddingTasksRequest {
	r.pageLimit = &pageLimit
	return r
}

func (r ApiListVideoEmbeddingTasksRequest) Execute() (*InlineObject16, *http.Response, error) {
	return r.ApiService.ListVideoEmbeddingTasksExecute(r)
}

/*
ListVideoEmbeddingTasks List video embedding tasks

This method returns a list of the video embedding tasks in your account. The platform returns your video embedding tasks sorted by creation date, with the newest at the top of the list.

<Note title="Notes">
- Video embeddings are stored for seven days
- When you invoke this method without specifying the `started_at` and `ended_at` parameters, the platform returns all the video embedding tasks created within the last seven days.
</Note>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVideoEmbeddingTasksRequest
*/
func (a *CreateVideoEmbeddingsAPIService) ListVideoEmbeddingTasks(ctx context.Context) ApiListVideoEmbeddingTasksRequest {
	return ApiListVideoEmbeddingTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineObject16
func (a *CreateVideoEmbeddingsAPIService) ListVideoEmbeddingTasksExecute(r ApiListVideoEmbeddingTasksRequest) (*InlineObject16, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject16
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreateVideoEmbeddingsAPIService.ListVideoEmbeddingTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embed/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}

	if r.startedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "started_at", r.startedAt, "form", "")
	}
	if r.endedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ended_at", r.endedAt, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_limit", r.pageLimit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageLimit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveVideoEmbeddingRequest struct {
	ctx context.Context
	ApiService *CreateVideoEmbeddingsAPIService
	xApiKey *string
	contentType *string
	taskId string
	embeddingOption *[]string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiRetrieveVideoEmbeddingRequest) XApiKey(xApiKey string) ApiRetrieveVideoEmbeddingRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiRetrieveVideoEmbeddingRequest) ContentType(contentType string) ApiRetrieveVideoEmbeddingRequest {
	r.contentType = &contentType
	return r
}

// Specifies which types of embeddings to retrieve. You can include one or more of the following values:   - &#x60;visual-text&#x60;:  Returns visual embeddings optimized for text search.   - &#x60;audio&#x60;: Returns audio embeddings.  The platform returns all available embeddings if you don&#39;t provide this parameter. 
func (r ApiRetrieveVideoEmbeddingRequest) EmbeddingOption(embeddingOption []string) ApiRetrieveVideoEmbeddingRequest {
	r.embeddingOption = &embeddingOption
	return r
}

func (r ApiRetrieveVideoEmbeddingRequest) Execute() (*InlineObject15, *http.Response, error) {
	return r.ApiService.RetrieveVideoEmbeddingExecute(r)
}

/*
RetrieveVideoEmbedding Retrieve video embeddings

This method retrieves embeddings for a specific video embedding task. Ensure the task status is `ready` before invoking this method. Refer to the [Retrieve the status of a video embedding tasks](/v1.3/api-reference/video-embeddings/retrieve-video-embedding-task-status) page for instructions on checking the task status.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The unique identifier of your video embedding task. 
 @return ApiRetrieveVideoEmbeddingRequest
*/
func (a *CreateVideoEmbeddingsAPIService) RetrieveVideoEmbedding(ctx context.Context, taskId string) ApiRetrieveVideoEmbeddingRequest {
	return ApiRetrieveVideoEmbeddingRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return InlineObject15
func (a *CreateVideoEmbeddingsAPIService) RetrieveVideoEmbeddingExecute(r ApiRetrieveVideoEmbeddingRequest) (*InlineObject15, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject15
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreateVideoEmbeddingsAPIService.RetrieveVideoEmbedding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embed/tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	if r.embeddingOption != nil {
		t := *r.embeddingOption
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "embedding_option", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "embedding_option", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveVideoEmbeddingTaskRequest struct {
	ctx context.Context
	ApiService *CreateVideoEmbeddingsAPIService
	xApiKey *string
	contentType *string
	taskId string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiRetrieveVideoEmbeddingTaskRequest) XApiKey(xApiKey string) ApiRetrieveVideoEmbeddingTaskRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiRetrieveVideoEmbeddingTaskRequest) ContentType(contentType string) ApiRetrieveVideoEmbeddingTaskRequest {
	r.contentType = &contentType
	return r
}

func (r ApiRetrieveVideoEmbeddingTaskRequest) Execute() (*InlineObject17, *http.Response, error) {
	return r.ApiService.RetrieveVideoEmbeddingTaskExecute(r)
}

/*
RetrieveVideoEmbeddingTask Retrieve the status of a video embedding task

This method retrieves the status of a video embedding task. Check the task status of a video embedding task to determine when you can retrieve the embedding.

A task can have one of the following statuses:
- `processing`: The platform is creating the embeddings.
- `ready`:  Processing is complete. Retrieve the embeddings by invoking the [`GET`](/v1.3/api-reference/video-embeddings/retrieve-video-embeddings) method of the `/embed/tasks/{task_id} endpoint`.
- `failed`: The task could not be completed, and the embeddings haven't been created.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The unique identifier of your video embedding task. 
 @return ApiRetrieveVideoEmbeddingTaskRequest
*/
func (a *CreateVideoEmbeddingsAPIService) RetrieveVideoEmbeddingTask(ctx context.Context, taskId string) ApiRetrieveVideoEmbeddingTaskRequest {
	return ApiRetrieveVideoEmbeddingTaskRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return InlineObject17
func (a *CreateVideoEmbeddingsAPIService) RetrieveVideoEmbeddingTaskExecute(r ApiRetrieveVideoEmbeddingTaskRequest) (*InlineObject17, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject17
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CreateVideoEmbeddingsAPIService.RetrieveVideoEmbeddingTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/embed/tasks/{task_id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
