/*
TwelveLabs Video Understanding API

Use the TwelveLabs Video Understanding API to extract information from your videos and make it available to your applications. The API is organized around REST and returns responses in the JSON format. It is compatible with most programming languages, and you can also use Postman or other REST clients to send requests and view responses. 

API version: 1.3.0
Contact: support@twelvelabs.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package twelvelabs

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ManageIndexesAPIService ManageIndexesAPI service
type ManageIndexesAPIService service

type ApiCreateIndexRequest struct {
	ctx context.Context
	ApiService *ManageIndexesAPIService
	xApiKey *string
	contentType *string
	createIndexRequest *CreateIndexRequest
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiCreateIndexRequest) XApiKey(xApiKey string) ApiCreateIndexRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiCreateIndexRequest) ContentType(contentType string) ApiCreateIndexRequest {
	r.contentType = &contentType
	return r
}

// Request to create an index. 
func (r ApiCreateIndexRequest) CreateIndexRequest(createIndexRequest CreateIndexRequest) ApiCreateIndexRequest {
	r.createIndexRequest = &createIndexRequest
	return r
}

func (r ApiCreateIndexRequest) Execute() (*InlineObject9, *http.Response, error) {
	return r.ApiService.CreateIndexExecute(r)
}

/*
CreateIndex Create an index

This method creates an index.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIndexRequest
*/
func (a *ManageIndexesAPIService) CreateIndex(ctx context.Context) ApiCreateIndexRequest {
	return ApiCreateIndexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineObject9
func (a *ManageIndexesAPIService) CreateIndexExecute(r ApiCreateIndexRequest) (*InlineObject9, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject9
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageIndexesAPIService.CreateIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/indexes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}
	if r.createIndexRequest == nil {
		return localVarReturnValue, nil, reportError("createIndexRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	// body params
	localVarPostBody = r.createIndexRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIndexRequest struct {
	ctx context.Context
	ApiService *ManageIndexesAPIService
	xApiKey *string
	contentType *string
	indexId string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiDeleteIndexRequest) XApiKey(xApiKey string) ApiDeleteIndexRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiDeleteIndexRequest) ContentType(contentType string) ApiDeleteIndexRequest {
	r.contentType = &contentType
	return r
}

func (r ApiDeleteIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteIndexExecute(r)
}

/*
DeleteIndex Delete an index

This method deletes the specified index and all the videos within it. This action cannot be undone.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId Unique identifier of the index to delete. 
 @return ApiDeleteIndexRequest
*/
func (a *ManageIndexesAPIService) DeleteIndex(ctx context.Context, indexId string) ApiDeleteIndexRequest {
	return ApiDeleteIndexRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
	}
}

// Execute executes the request
func (a *ManageIndexesAPIService) DeleteIndexExecute(r ApiDeleteIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageIndexesAPIService.DeleteIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/indexes/{index-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index-id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListIndexesRequest struct {
	ctx context.Context
	ApiService *ManageIndexesAPIService
	xApiKey *string
	contentType *string
	page *int32
	pageLimit *int32
	sortBy *string
	sortOption *string
	indexName *string
	modelOptions *string
	modelFamily *string
	createdAt *string
	updatedAt *string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiListIndexesRequest) XApiKey(xApiKey string) ApiListIndexesRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiListIndexesRequest) ContentType(contentType string) ApiListIndexesRequest {
	r.contentType = &contentType
	return r
}

// A number that identifies the page to retrieve.  **Default**: &#x60;1&#x60;. 
func (r ApiListIndexesRequest) Page(page int32) ApiListIndexesRequest {
	r.page = &page
	return r
}

// The number of items to return on each page.  **Default**: &#x60;10&#x60;. **Max**: &#x60;50&#x60;. 
func (r ApiListIndexesRequest) PageLimit(pageLimit int32) ApiListIndexesRequest {
	r.pageLimit = &pageLimit
	return r
}

// The field to sort on. The following options are available: - &#x60;updated_at&#x60;: Sorts by the time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;), when the item was updated. - &#x60;created_at&#x60;: Sorts by the time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;), when the item was created.  **Default**: &#x60;created_at&#x60;. 
func (r ApiListIndexesRequest) SortBy(sortBy string) ApiListIndexesRequest {
	r.sortBy = &sortBy
	return r
}

// The sorting direction. The following options are available: - &#x60;asc&#x60; - &#x60;desc&#x60;  **Default**: &#x60;desc&#x60;. 
func (r ApiListIndexesRequest) SortOption(sortOption string) ApiListIndexesRequest {
	r.sortOption = &sortOption
	return r
}

// Filter by the name of an index.
func (r ApiListIndexesRequest) IndexName(indexName string) ApiListIndexesRequest {
	r.indexName = &indexName
	return r
}

// Filter by the model options. When filtering by multiple model options, the values must be comma-separated. 
func (r ApiListIndexesRequest) ModelOptions(modelOptions string) ApiListIndexesRequest {
	r.modelOptions = &modelOptions
	return r
}

// Filter by the model family. This parameter can take one of the following values: &#x60;marengo&#x60; or &#x60;pegasus&#x60;. You can specify a single value. 
func (r ApiListIndexesRequest) ModelFamily(modelFamily string) ApiListIndexesRequest {
	r.modelFamily = &modelFamily
	return r
}

// Filter indexes by the creation date and time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;). The platform returns the indexes that were created on the specified date at or after the given time. 
func (r ApiListIndexesRequest) CreatedAt(createdAt string) ApiListIndexesRequest {
	r.createdAt = &createdAt
	return r
}

// Filter indexes by the last update date and time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;). The platform returns the indexes that were last updated on the specified date at or after the given time. 
func (r ApiListIndexesRequest) UpdatedAt(updatedAt string) ApiListIndexesRequest {
	r.updatedAt = &updatedAt
	return r
}

func (r ApiListIndexesRequest) Execute() (*InlineObject7, *http.Response, error) {
	return r.ApiService.ListIndexesExecute(r)
}

/*
ListIndexes List indexes

This method returns a list of the indexes in your account. The API returns indexes sorted by creation date, with the oldest indexes at the top of the list.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListIndexesRequest
*/
func (a *ManageIndexesAPIService) ListIndexes(ctx context.Context) ApiListIndexesRequest {
	return ApiListIndexesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineObject7
func (a *ManageIndexesAPIService) ListIndexesExecute(r ApiListIndexesRequest) (*InlineObject7, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject7
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageIndexesAPIService.ListIndexes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/indexes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_limit", r.pageLimit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageLimit = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortBy = &defaultValue
	}
	if r.sortOption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_option", r.sortOption, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortOption = &defaultValue
	}
	if r.indexName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index_name", r.indexName, "form", "")
	}
	if r.modelOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model_options", r.modelOptions, "form", "")
	}
	if r.modelFamily != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model_family", r.modelFamily, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveIndexRequest struct {
	ctx context.Context
	ApiService *ManageIndexesAPIService
	xApiKey *string
	contentType *string
	indexId string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiRetrieveIndexRequest) XApiKey(xApiKey string) ApiRetrieveIndexRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiRetrieveIndexRequest) ContentType(contentType string) ApiRetrieveIndexRequest {
	r.contentType = &contentType
	return r
}

func (r ApiRetrieveIndexRequest) Execute() (*Index, *http.Response, error) {
	return r.ApiService.RetrieveIndexExecute(r)
}

/*
RetrieveIndex Retrieve an index

This method retrieves details about the specified index.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId Unique identifier of the index to retrieve. 
 @return ApiRetrieveIndexRequest
*/
func (a *ManageIndexesAPIService) RetrieveIndex(ctx context.Context, indexId string) ApiRetrieveIndexRequest {
	return ApiRetrieveIndexRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
	}
}

// Execute executes the request
//  @return Index
func (a *ManageIndexesAPIService) RetrieveIndexExecute(r ApiRetrieveIndexRequest) (*Index, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Index
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageIndexesAPIService.RetrieveIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/indexes/{index-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index-id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIndexRequest struct {
	ctx context.Context
	ApiService *ManageIndexesAPIService
	xApiKey *string
	contentType *string
	indexId string
	updateIndexRequest *UpdateIndexRequest
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiUpdateIndexRequest) XApiKey(xApiKey string) ApiUpdateIndexRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiUpdateIndexRequest) ContentType(contentType string) ApiUpdateIndexRequest {
	r.contentType = &contentType
	return r
}

// Request to update the name of an index. 
func (r ApiUpdateIndexRequest) UpdateIndexRequest(updateIndexRequest UpdateIndexRequest) ApiUpdateIndexRequest {
	r.updateIndexRequest = &updateIndexRequest
	return r
}

func (r ApiUpdateIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateIndexExecute(r)
}

/*
UpdateIndex Update an index

This method updates the name of the specified index.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param indexId Unique identifier of the index to update. 
 @return ApiUpdateIndexRequest
*/
func (a *ManageIndexesAPIService) UpdateIndex(ctx context.Context, indexId string) ApiUpdateIndexRequest {
	return ApiUpdateIndexRequest{
		ApiService: a,
		ctx: ctx,
		indexId: indexId,
	}
}

// Execute executes the request
func (a *ManageIndexesAPIService) UpdateIndexExecute(r ApiUpdateIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManageIndexesAPIService.UpdateIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/indexes/{index-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"index-id"+"}", url.PathEscape(parameterValueToString(r.indexId, "indexId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	// body params
	localVarPostBody = r.updateIndexRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
