/*
TwelveLabs Video Understanding API

Use the TwelveLabs Video Understanding API to extract information from your videos and make it available to your applications. The API is organized around REST and returns responses in the JSON format. It is compatible with most programming languages, and you can also use Postman or other REST clients to send requests and view responses. 

API version: 1.3.0
Contact: support@twelvelabs.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package twelvelabs

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// UploadVideosAPIService UploadVideosAPI service
type UploadVideosAPIService service

type ApiCloudToCloudImportVideosRequest struct {
	ctx context.Context
	ApiService *UploadVideosAPIService
	xApiKey *string
	contentType *string
	integrationId string
	cloudToCloudImportVideosRequest *CloudToCloudImportVideosRequest
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiCloudToCloudImportVideosRequest) XApiKey(xApiKey string) ApiCloudToCloudImportVideosRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiCloudToCloudImportVideosRequest) ContentType(contentType string) ApiCloudToCloudImportVideosRequest {
	r.contentType = &contentType
	return r
}

// Request to import videos from a cloud storage bucket to an index. 
func (r ApiCloudToCloudImportVideosRequest) CloudToCloudImportVideosRequest(cloudToCloudImportVideosRequest CloudToCloudImportVideosRequest) ApiCloudToCloudImportVideosRequest {
	r.cloudToCloudImportVideosRequest = &cloudToCloudImportVideosRequest
	return r
}

func (r ApiCloudToCloudImportVideosRequest) Execute() (*InlineObject20, *http.Response, error) {
	return r.ApiService.CloudToCloudImportVideosExecute(r)
}

/*
CloudToCloudImportVideos Import videos

An import represents the process of uploading and indexing all videos from the specified integration.

This method initiates an asynchronous import and returns two lists:
- Videos that will be imported.
- Videos that will not be imported, typically because they do not meet the prerequisites of all enabled video understanding models for your index. Note that the most restrictive prerequisites among the enabled models will apply.

The actual uploading and indexing of videos occur asynchronously after you invoke this method. To monitor the status of each upload after invoking this method, use the [Retrieve import status](/v1.3/api-reference/tasks/cloud-to-cloud-integrations/get-status) method.

<Accordion title="Video requirements">
  The videos you wish to upload must meet the following requirements:
  - **Video resolution**: Must be at least 360x360 and must not exceed 3840x2160.
  - **Aspect ratio**: Must be one of 1:1, 4:3, 4:5, 5:4, 16:9, or 9:16.
  - **Video and audio formats**: Your video files must be encoded in the video and audio formats listed on the [FFmpeg Formats Documentation](https://ffmpeg.org/ffmpeg-formats.html) page. For videos in other formats, contact us at support@twelvelabs.io.
  - **Duration**: For Marengo, it must be between 4 seconds and 2 hours (7,200s). For Pegasus, it must be between 4 seconds and 60 minutes (3600s). In a future release, the maximum duration for Pegasus will be 2 hours (7,200 seconds).
  - **File size**: Must not exceed 2 GB.
    If you require different options, contact us at support@twelvelabs.io.

  If both Marengo and Pegasus are enabled for your index, the most restrictive prerequisites will apply.
</Accordion>

<Note title="Notes">
- Before importing videos, you must set up an integration. For details, see the [Set up an integration](/v1.3/docs/advanced/cloud-to-cloud-integrations#set-up-an-integration) section.
- By default, the platform checks for duplicate files using hashes within the target index and will not upload the same video to the same index twice. However, the same video can exist in multiple indexes. To bypass duplicate checking entirely and import duplicate videos into the same index, set the value of the `incremental_import` parameter to `false`.
- Only one import job can run at a time. To start a new import, wait for the current job to complete. Use the [`GET`](/v1.3/api-reference/tasks/cloud-to-cloud-integrations/get-status) method of the `/tasks/transfers/import/{integration-id}/logs` endpoint to retrieve a list of your import jobs, including their creation time, completion time, and processing status for each video file.
</Note>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationId The unique identifier of the integration for which you want to import videos. You can retrieve it from the [Integrations](https://playground.twelvelabs.io/dashboard/integrations) page.
 @return ApiCloudToCloudImportVideosRequest
*/
func (a *UploadVideosAPIService) CloudToCloudImportVideos(ctx context.Context, integrationId string) ApiCloudToCloudImportVideosRequest {
	return ApiCloudToCloudImportVideosRequest{
		ApiService: a,
		ctx: ctx,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return InlineObject20
func (a *UploadVideosAPIService) CloudToCloudImportVideosExecute(r ApiCloudToCloudImportVideosRequest) (*InlineObject20, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject20
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadVideosAPIService.CloudToCloudImportVideos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/transfers/import/{integration-id}"
	localVarPath = strings.Replace(localVarPath, "{"+"integration-id"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}
	if r.cloudToCloudImportVideosRequest == nil {
		return localVarReturnValue, nil, reportError("cloudToCloudImportVideosRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	// body params
	localVarPostBody = r.cloudToCloudImportVideosRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCloudToCloudRetrieveImportLogsRequest struct {
	ctx context.Context
	ApiService *UploadVideosAPIService
	xApiKey *string
	contentType *string
	integrationId string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiCloudToCloudRetrieveImportLogsRequest) XApiKey(xApiKey string) ApiCloudToCloudRetrieveImportLogsRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiCloudToCloudRetrieveImportLogsRequest) ContentType(contentType string) ApiCloudToCloudRetrieveImportLogsRequest {
	r.contentType = &contentType
	return r
}

func (r ApiCloudToCloudRetrieveImportLogsRequest) Execute() (*InlineObject, *http.Response, error) {
	return r.ApiService.CloudToCloudRetrieveImportLogsExecute(r)
}

/*
CloudToCloudRetrieveImportLogs Retrieve import logs

This endpoint returns a chronological list of import operations for the specified integration. The list is sorted by creation date, with the oldest imports first. Each item in the list contains:
- The number of videos in each status
- Detailed error information for failed uploads, including filenames and error messages.

Use this endpoint to track import progress and troubleshoot potential issues across multiple operations.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationId The unique identifier of the integration for which you want to retrieve the import logs. You can retrieve it from the [Integrations](https://playground.twelvelabs.io/dashboard/integrations) page.
 @return ApiCloudToCloudRetrieveImportLogsRequest
*/
func (a *UploadVideosAPIService) CloudToCloudRetrieveImportLogs(ctx context.Context, integrationId string) ApiCloudToCloudRetrieveImportLogsRequest {
	return ApiCloudToCloudRetrieveImportLogsRequest{
		ApiService: a,
		ctx: ctx,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return InlineObject
func (a *UploadVideosAPIService) CloudToCloudRetrieveImportLogsExecute(r ApiCloudToCloudRetrieveImportLogsRequest) (*InlineObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadVideosAPIService.CloudToCloudRetrieveImportLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/transfers/import/{integration-id}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"integration-id"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCloudToCloudRetrieveStatusRequest struct {
	ctx context.Context
	ApiService *UploadVideosAPIService
	xApiKey *string
	contentType *string
	integrationId string
	indexId *string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiCloudToCloudRetrieveStatusRequest) XApiKey(xApiKey string) ApiCloudToCloudRetrieveStatusRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiCloudToCloudRetrieveStatusRequest) ContentType(contentType string) ApiCloudToCloudRetrieveStatusRequest {
	r.contentType = &contentType
	return r
}

// The unique identifier of the index for which you want to retrieve the status of your imported videos. 
func (r ApiCloudToCloudRetrieveStatusRequest) IndexId(indexId string) ApiCloudToCloudRetrieveStatusRequest {
	r.indexId = &indexId
	return r
}

func (r ApiCloudToCloudRetrieveStatusRequest) Execute() (*InlineObject21, *http.Response, error) {
	return r.ApiService.CloudToCloudRetrieveStatusExecute(r)
}

/*
CloudToCloudRetrieveStatus Retrieve import status

This method retrieves the current status for each video from a specified integration and index. It returns an object containing lists of videos grouped by status. See the [Task object](/v1.3/api-reference/tasks/the-task-object) page for details on each status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param integrationId The unique identifier of the integration for which you want to retrieve the status of your imported videos. You can retrieve it from the [Integrations](https://playground.twelvelabs.io/dashboard/integrations) page.
 @return ApiCloudToCloudRetrieveStatusRequest
*/
func (a *UploadVideosAPIService) CloudToCloudRetrieveStatus(ctx context.Context, integrationId string) ApiCloudToCloudRetrieveStatusRequest {
	return ApiCloudToCloudRetrieveStatusRequest{
		ApiService: a,
		ctx: ctx,
		integrationId: integrationId,
	}
}

// Execute executes the request
//  @return InlineObject21
func (a *UploadVideosAPIService) CloudToCloudRetrieveStatusExecute(r ApiCloudToCloudRetrieveStatusRequest) (*InlineObject21, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject21
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadVideosAPIService.CloudToCloudRetrieveStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/transfers/import/{integration-id}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"integration-id"+"}", url.PathEscape(parameterValueToString(r.integrationId, "integrationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}
	if r.indexId == nil {
		return localVarReturnValue, nil, reportError("indexId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "index_id", r.indexId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVideoIndexingTaskRequest struct {
	ctx context.Context
	ApiService *UploadVideosAPIService
	xApiKey *string
	contentType *string
	indexId *string
	videoFile *os.File
	videoUrl *string
	enableVideoStream *bool
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiCreateVideoIndexingTaskRequest) XApiKey(xApiKey string) ApiCreateVideoIndexingTaskRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;multipart/form-data&#x60;.
func (r ApiCreateVideoIndexingTaskRequest) ContentType(contentType string) ApiCreateVideoIndexingTaskRequest {
	r.contentType = &contentType
	return r
}

// The unique identifier of the index to which the video is being uploaded. 
func (r ApiCreateVideoIndexingTaskRequest) IndexId(indexId string) ApiCreateVideoIndexingTaskRequest {
	r.indexId = &indexId
	return r
}

// Specify this parameter to upload a video from your local file system. 
func (r ApiCreateVideoIndexingTaskRequest) VideoFile(videoFile *os.File) ApiCreateVideoIndexingTaskRequest {
	r.videoFile = videoFile
	return r
}

// Specify this parameter to upload a video from a publicly accessible URL. 
func (r ApiCreateVideoIndexingTaskRequest) VideoUrl(videoUrl string) ApiCreateVideoIndexingTaskRequest {
	r.videoUrl = &videoUrl
	return r
}

// This parameter indicates if the platform stores the video for streaming. When set to &#x60;true&#x60;, the platform stores the video, and you can retrieve its URL by calling the [&#x60;GET&#x60;](/v1.3/api-reference/videos/retrieve) method of the &#x60;/indexes/{index-id}/videos/{video-id}&#x60; endpoint. You can then use this URL to access the stream over the &lt;a href&#x3D;\\\&quot;https://en.wikipedia.org/wiki/HTTP_Live_Streaming\\\&quot; target&#x3D;\\\&quot;_blank\\\&quot;&gt;HLS&lt;/a&gt; protocol. 
func (r ApiCreateVideoIndexingTaskRequest) EnableVideoStream(enableVideoStream bool) ApiCreateVideoIndexingTaskRequest {
	r.enableVideoStream = &enableVideoStream
	return r
}

func (r ApiCreateVideoIndexingTaskRequest) Execute() (*InlineObject8, *http.Response, error) {
	return r.ApiService.CreateVideoIndexingTaskExecute(r)
}

/*
CreateVideoIndexingTask Create a video indexing task

This method creates a video indexing task that uploads and indexes a video.

Upload options:
- **Local file**: Use the `video_file` parameter.
- **Publicly accessible URL**: Use the `video_url` parameter.

<Accordion title="Video requirements">
  The videos you wish to upload must meet the following requirements:
  - **Video resolution**: Must be at least 360x360 and must not exceed 3840x2160.
  - **Aspect ratio**: Must be one of 1:1, 4:3, 4:5, 5:4, 16:9, or 9:16.
  - **Video and audio formats**: Your video files must be encoded in the video and audio formats listed on the [FFmpeg Formats Documentation](https://ffmpeg.org/ffmpeg-formats.html) page. For videos in other formats, contact us at support@twelvelabs.io.
  - **Duration**: For Marengo, it must be between 4 seconds and 2 hours (7,200s). For Pegasus, it must be between 4 seconds and 60 minutes (3600s). In a future release, the maximum duration for Pegasus will be 2 hours (7,200 seconds).
  - **File size**: Must not exceed 2 GB.
    If you require different options, contact us at support@twelvelabs.io.
  
  If both Marengo and Pegasus are enabled for your index, the most restrictive prerequisites will apply.
</Accordion>

<Note title="Notes">
- The platform supports video URLs that can play without additional user interaction or custom video players. Ensure your URL points to the raw video file, not a web page containing the video. Links to third-party hosting sites, cloud storage services, or videos requiring extra steps to play are not supported.
- This endpoint is rate-limited. For details, see the [Rate limits](/v1.3/docs/get-started/rate-limits) page.
</Note>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVideoIndexingTaskRequest
*/
func (a *UploadVideosAPIService) CreateVideoIndexingTask(ctx context.Context) ApiCreateVideoIndexingTaskRequest {
	return ApiCreateVideoIndexingTaskRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineObject8
func (a *UploadVideosAPIService) CreateVideoIndexingTaskExecute(r ApiCreateVideoIndexingTaskRequest) (*InlineObject8, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject8
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadVideosAPIService.CreateVideoIndexingTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}
	if r.indexId == nil {
		return localVarReturnValue, nil, reportError("indexId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "index_id", r.indexId, "", "")
	var videoFileLocalVarFormFileName string
	var videoFileLocalVarFileName     string
	var videoFileLocalVarFileBytes    []byte

	videoFileLocalVarFormFileName = "video_file"
	videoFileLocalVarFile := r.videoFile

	if videoFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(videoFileLocalVarFile)

		videoFileLocalVarFileBytes = fbs
		videoFileLocalVarFileName = videoFileLocalVarFile.Name()
		videoFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: videoFileLocalVarFileBytes, fileName: videoFileLocalVarFileName, formFileName: videoFileLocalVarFormFileName})
	}
	if r.videoUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "video_url", r.videoUrl, "", "")
	}
	if r.enableVideoStream != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "enable_video_stream", r.enableVideoStream, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject11
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVideoIndexingTaskRequest struct {
	ctx context.Context
	ApiService *UploadVideosAPIService
	xApiKey *string
	contentType *string
	taskId string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiDeleteVideoIndexingTaskRequest) XApiKey(xApiKey string) ApiDeleteVideoIndexingTaskRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiDeleteVideoIndexingTaskRequest) ContentType(contentType string) ApiDeleteVideoIndexingTaskRequest {
	r.contentType = &contentType
	return r
}

func (r ApiDeleteVideoIndexingTaskRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVideoIndexingTaskExecute(r)
}

/*
DeleteVideoIndexingTask Delete a video indexing task

This action cannot be undone.
Note the following about deleting a video indexing task:
- You can only delete video indexing tasks for which the status is `ready` or `failed`.
- If the status of your video indexing task is `ready`, you must first delete the video vector associated with your video indexing task by calling the [`DELETE`](/v1.3/api-reference/videos/delete) method of the `/indexes/videos` endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The unique identifier of the video indexing task you want to delete. 
 @return ApiDeleteVideoIndexingTaskRequest
*/
func (a *UploadVideosAPIService) DeleteVideoIndexingTask(ctx context.Context, taskId string) ApiDeleteVideoIndexingTaskRequest {
	return ApiDeleteVideoIndexingTaskRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
func (a *UploadVideosAPIService) DeleteVideoIndexingTaskExecute(r ApiDeleteVideoIndexingTaskRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadVideosAPIService.DeleteVideoIndexingTask")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListVideoIndexingTasksRequest struct {
	ctx context.Context
	ApiService *UploadVideosAPIService
	xApiKey *string
	contentType *string
	page *int32
	pageLimit *int32
	sortBy *string
	sortOption *string
	indexId *string
	status *[]string
	filename *string
	duration *float32
	width *int32
	height *int32
	createdAt *string
	updatedAt *string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiListVideoIndexingTasksRequest) XApiKey(xApiKey string) ApiListVideoIndexingTasksRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiListVideoIndexingTasksRequest) ContentType(contentType string) ApiListVideoIndexingTasksRequest {
	r.contentType = &contentType
	return r
}

// A number that identifies the page to retrieve.  **Default**: &#x60;1&#x60;. 
func (r ApiListVideoIndexingTasksRequest) Page(page int32) ApiListVideoIndexingTasksRequest {
	r.page = &page
	return r
}

// The number of items to return on each page.  **Default**: &#x60;10&#x60;. **Max**: &#x60;50&#x60;. 
func (r ApiListVideoIndexingTasksRequest) PageLimit(pageLimit int32) ApiListVideoIndexingTasksRequest {
	r.pageLimit = &pageLimit
	return r
}

// The field to sort on. The following options are available: - &#x60;updated_at&#x60;: Sorts by the time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;), when the item was updated. - &#x60;created_at&#x60;: Sorts by the time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;), when the item was created.  **Default**: &#x60;created_at&#x60;. 
func (r ApiListVideoIndexingTasksRequest) SortBy(sortBy string) ApiListVideoIndexingTasksRequest {
	r.sortBy = &sortBy
	return r
}

// The sorting direction. The following options are available: - &#x60;asc&#x60; - &#x60;desc&#x60;  **Default**: &#x60;desc&#x60;. 
func (r ApiListVideoIndexingTasksRequest) SortOption(sortOption string) ApiListVideoIndexingTasksRequest {
	r.sortOption = &sortOption
	return r
}

// Filter by the unique identifier of an index. 
func (r ApiListVideoIndexingTasksRequest) IndexId(indexId string) ApiListVideoIndexingTasksRequest {
	r.indexId = &indexId
	return r
}

// Filter by one or more video indexing task statuses. The following options are available: - &#x60;ready&#x60;: The video has been successfully uploaded and indexed. - &#x60;uploading&#x60;: The video is being uploaded. - &#x60;validating&#x60;: The video is being validated against the prerequisites. - &#x60;pending&#x60;: The video is pending. - &#x60;queued&#x60;: The video is queued. - &#x60;indexing&#x60;: The video is being indexed. - &#x60;failed&#x60;: The video indexing task failed.  To filter by multiple statuses, specify the &#x60;status&#x60; parameter for each value: &#x60;&#x60;&#x60; status&#x3D;ready&amp;status&#x3D;validating &#x60;&#x60;&#x60; 
func (r ApiListVideoIndexingTasksRequest) Status(status []string) ApiListVideoIndexingTasksRequest {
	r.status = &status
	return r
}

// Filter by filename. 
func (r ApiListVideoIndexingTasksRequest) Filename(filename string) ApiListVideoIndexingTasksRequest {
	r.filename = &filename
	return r
}

// Filter by duration. Expressed in seconds. 
func (r ApiListVideoIndexingTasksRequest) Duration(duration float32) ApiListVideoIndexingTasksRequest {
	r.duration = &duration
	return r
}

// Filter by width. 
func (r ApiListVideoIndexingTasksRequest) Width(width int32) ApiListVideoIndexingTasksRequest {
	r.width = &width
	return r
}

// Filter by height. 
func (r ApiListVideoIndexingTasksRequest) Height(height int32) ApiListVideoIndexingTasksRequest {
	r.height = &height
	return r
}

// Filter video indexing tasks by the creation date and time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;). The platform returns the video indexing tasks that were created on the specified date at or after the given time. 
func (r ApiListVideoIndexingTasksRequest) CreatedAt(createdAt string) ApiListVideoIndexingTasksRequest {
	r.createdAt = &createdAt
	return r
}

// Filter video indexing tasks by the last update date and time, in the RFC 3339 format (\&quot;YYYY-MM-DDTHH:mm:ssZ\&quot;). The platform returns the video indexing tasks that were updated on the specified date at or after the given time. 
func (r ApiListVideoIndexingTasksRequest) UpdatedAt(updatedAt string) ApiListVideoIndexingTasksRequest {
	r.updatedAt = &updatedAt
	return r
}

func (r ApiListVideoIndexingTasksRequest) Execute() (*InlineObject5, *http.Response, error) {
	return r.ApiService.ListVideoIndexingTasksExecute(r)
}

/*
ListVideoIndexingTasks List video indexing tasks

This method returns a list of the video indexing tasks in your account. The API returns your video indexing tasks sorted by creation date, with the newest at the top of the list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVideoIndexingTasksRequest
*/
func (a *UploadVideosAPIService) ListVideoIndexingTasks(ctx context.Context) ApiListVideoIndexingTasksRequest {
	return ApiListVideoIndexingTasksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineObject5
func (a *UploadVideosAPIService) ListVideoIndexingTasksExecute(r ApiListVideoIndexingTasksRequest) (*InlineObject5, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject5
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadVideosAPIService.ListVideoIndexingTasks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_limit", r.pageLimit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.pageLimit = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortBy = &defaultValue
	}
	if r.sortOption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_option", r.sortOption, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortOption = &defaultValue
	}
	if r.indexId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "index_id", r.indexId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "csv")
	}
	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRetrieveVideoIndexingTaskRequest struct {
	ctx context.Context
	ApiService *UploadVideosAPIService
	xApiKey *string
	contentType *string
	taskId string
}

// Your API key.  &lt;Note title&#x3D;\&quot;Note\&quot;&gt; You can find your API key on the &lt;a href&#x3D;\&quot;https://playground.twelvelabs.io/dashboard/api-key\&quot; target&#x3D;\&quot;_blank\&quot;&gt;API Key&lt;/a&gt; page. &lt;/Note&gt; 
func (r ApiRetrieveVideoIndexingTaskRequest) XApiKey(xApiKey string) ApiRetrieveVideoIndexingTaskRequest {
	r.xApiKey = &xApiKey
	return r
}

// Must be set to &#x60;application/json&#x60;.
func (r ApiRetrieveVideoIndexingTaskRequest) ContentType(contentType string) ApiRetrieveVideoIndexingTaskRequest {
	r.contentType = &contentType
	return r
}

func (r ApiRetrieveVideoIndexingTaskRequest) Execute() (*InlineObject6, *http.Response, error) {
	return r.ApiService.RetrieveVideoIndexingTaskExecute(r)
}

/*
RetrieveVideoIndexingTask Retrieve a video indexing task

This method retrieves a video indexing task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId The unique identifier of the video indexing task to retrieve. 
 @return ApiRetrieveVideoIndexingTaskRequest
*/
func (a *UploadVideosAPIService) RetrieveVideoIndexingTask(ctx context.Context, taskId string) ApiRetrieveVideoIndexingTaskRequest {
	return ApiRetrieveVideoIndexingTaskRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return InlineObject6
func (a *UploadVideosAPIService) RetrieveVideoIndexingTaskExecute(r ApiRetrieveVideoIndexingTaskRequest) (*InlineObject6, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InlineObject6
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadVideosAPIService.RetrieveVideoIndexingTask")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tasks/{task_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"task_id"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xApiKey == nil {
		return localVarReturnValue, nil, reportError("xApiKey is required and must be specified")
	}
	if r.contentType == nil {
		return localVarReturnValue, nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-api-key", r.xApiKey, "simple", "")
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Content-Type", r.contentType, "simple", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineObject13
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
